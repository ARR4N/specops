package specialops

import (
	"fmt"

	"github.com/ethereum/go-ethereum/core/vm"
)

// A stackDelta carries the number of values popped and pushed by an opcode.
// Values are generated by the opcopy binary.
type stackDelta struct {
	pop, push uint
}

// ExpectStackDepth is a sentinel value that singals to Code.Compile() that it
// must assert the expected stack depth, returning an error if incorrect. See
// SetStackDepth() for caveats; note that the expectation is with respect to
// Compile() and has nothing to do with concrete (runtime) depths.
type ExpectStackDepth uint

// Bytecode always returns an error.
func (d ExpectStackDepth) Bytecode() ([]byte, error) {
	return nil, fmt.Errorf("call to %T.Bytecode()", d)
}

// SetStackDepth is a sentinel value that signals to Code.Compile() that it must
// modify its internal counter reflecting the current stack depth.
//
// For each vm.OpCode that it encounters, Code.Compile() adjusts a value that
// reflects its belief about the stack depth. This is a crude mechanism that
// only works for non-JUMPing code. The programmer can therefore signal,
// typically after a JUMPDEST, the actual stack depth.
type SetStackDepth uint

// Bytecode always returns an error.
func (d SetStackDepth) Bytecode() ([]byte, error) {
	return nil, fmt.Errorf("call to %T.Bytecode()", d)
}

// Inverted applies DUP<X> and SWAP<X> opcodes relative to the bottom-most value
// on the stack unless there are more than 16 values, in which case they are
// applied relative to the 16th.
//
// For a stack with n <= 16 values on it, `Inverted(DUP1)` and `Inverted(SWAP1)`
// will apply to the nth value instead of the first. Similarly, `Inverted(DUP2)`
// will apply to the (n-1)the value, etc. For a stack with >16 items, the same
// logic applies but with n = 16.
//
// Note that the semantics disallow `Inverted(SWAP16)` as it would be a noop. In
// fact, in all cases, inverted SWAPs are capped at `depth-1`. While they could
// be offset by one (like regular SWAPs) this is less intuitive than
// `Inverted(SWAP1)` being the bottom of a (sub-16-depth) stack.
//
// See SetStackDepth() for caveats. It is best practice to use `Inverted` in
// conjunction with {Set/Expect}StackDepth().
type Inverted vm.OpCode

// Bytecode always returns an error.
func (i Inverted) Bytecode() ([]byte, error) {
	return nil, fmt.Errorf("call to %T.Bytecode()", i)
}
